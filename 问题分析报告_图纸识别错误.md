# 图纸识别错误深度分析报告

## 📋 问题概述

在最近一次图纸生成中，出现了严重的识别错误：
- ❌ 组件图1、2、4 都找不到对应的AI规划
- ❌ 组件图3 没有BOM数据
- ❌ 最终组件级别处理完成：**0个组件**
- ❌ 大量文件不存在

## 🔍 根本原因分析

### 问题1：AI规划的base_part_code与实际BOM数据不匹配

#### 匹配逻辑（core/hierarchical_bom_matcher_v2.py 第89-115行）

```python
# 步骤1：先获取该组件图的BOM数据
component_bom_for_matching = self._get_component_bom_by_file_index(bom_data, file_index)

# 步骤2：提取第一个零件的code（base_part）
base_part_code = component_bom_for_matching[0].get("code", "")

# 步骤3：在component_plans中查找base_part_code匹配的组件
comp_plan = None
for plan in component_plans:
    if plan.get("base_part_code") == base_part_code:
        comp_plan = plan
        break

if not comp_plan:
    print_warning(f"未找到组件图{file_index}对应的AI规划（base_part_code={base_part_code}），跳过")
    continue
```

#### 实际对比

| 组件图 | BOM第一个零件code | AI规划的base_part_code | 是否匹配 |
|--------|-------------------|------------------------|----------|
| 组件图1 | `01.01.03.0693` | `01.01.03.0692` | ❌ 不匹配 |
| 组件图2 | `01.02.01.3870` | `01.02.03.0206` | ❌ 不匹配 |
| 组件图3 | *无BOM数据* | `01.01.02.1869` | ❌ 无法匹配 |
| 组件图4 | `01.01.16586` | `01.03.0190` | ❌ 不匹配 |

**结论**：4个组件图全部匹配失败！

---

### 问题2：Agent 1（视觉规划）识别错误

#### Agent 1的任务（prompts/agent_1_vision_planning.py）

Agent 1需要：
1. 观察产品总图，识别所有组件
2. 观察每个组件图，识别组件内的零件
3. 为每个组件选择**最重的零件**作为base_part

#### 错误案例分析

**组件1（挂架组件-漆后）**

AI规划说：
```json
{
  "base_part_code": "01.01.03.0692",
  "base_part_name": "方管",
  "base_part_weight_kg": 26.16
}
```

实际BOM数据（组件图1.PDF）：
```json
[
  {"seq": "1", "code": "01.01.03.0693", "name": "方管", "weight": 7.34},  // ← 第一个零件
  {"seq": "2", "code": "01.01.03.0692", "name": "方管", "weight": 26.16}, // ← AI选的这个
  ...
]
```

**问题**：
- AI选择了BOM表中**第2行**的零件（26.16kg）作为base_part
- 但匹配逻辑使用的是BOM表**第1行**的零件（7.34kg）
- **序号不一致导致匹配失败**

---

### 问题3：组件图3没有BOM数据

从step2_bom_data.json看：
- 产品总图.PDF: 38个零件
- 组件图1.PDF: 13个零件
- 组件图2.pdf: 9个零件
- **组件图3.PDF: 0个零件** ← 这里出问题了
- 组件图4.PDF: 4个零件

**可能原因**：
1. PDF解析失败（Gemini视觉模型没有识别出BOM表）
2. BOM表格式异常（表格边框不清晰、文字模糊）
3. 图纸质量问题（扫描件、分辨率低）

---

## 🎯 问题根源总结

### 根源1：AI视觉识别不稳定

**Agent 1的视觉识别存在以下问题**：

1. **零件序号识别错误**
   - AI看到的"图纸序号②"可能对应BOM表的第2行，也可能对应第3行
   - 没有严格的"图纸序号 → BOM行号"的映射机制

2. **"最重零件"判断错误**
   - AI可能被图纸上的视觉大小误导
   - AI可能混淆了不同组件图的零件

3. **跨图纸信息混淆**
   - AI同时看到4张组件图 + 1张产品总图
   - 可能把组件图2的零件误认为是组件图1的零件

### 根源2：匹配逻辑过于简单

**当前匹配逻辑的假设**：
```
BOM表第1行的零件 = 组件的base_part = AI规划的base_part_code
```

**这个假设不成立的原因**：
1. BOM表的排序不一定按重量排序
2. BOM表的排序不一定按装配顺序排序
3. AI识别的base_part可能不是BOM表的第1行

### 根源3：缺少容错机制

**当匹配失败时**：
- 直接跳过整个组件
- 没有尝试其他匹配策略（如模糊匹配、名称匹配、重量匹配）
- 没有给用户提供手动修正的机会

---

## 💡 解决方案

### 方案1：改进匹配逻辑（短期方案）

**策略1：多候选匹配**

不再只用BOM第1行，而是尝试前3行：

```python
# 尝试前3个零件作为候选base_part
for candidate_index in range(min(3, len(component_bom_for_matching))):
    base_part_code = component_bom_for_matching[candidate_index].get("code", "")
    
    # 在component_plans中查找匹配
    for plan in component_plans:
        if plan.get("base_part_code") == base_part_code:
            comp_plan = plan
            print_info(f"✅ 匹配成功（使用BOM第{candidate_index+1}行）")
            break
    
    if comp_plan:
        break
```

**策略2：模糊匹配**

如果精确匹配失败，尝试：
- 名称相似度匹配（如"方管" vs "方管-机加"）
- 重量接近度匹配（±10%误差）
- 材料匹配（Q355B、Q235等）

**策略3：组件名称匹配**

```python
# 如果base_part匹配失败，尝试用component_code匹配
for plan in component_plans:
    if plan.get("component_code") == comp_code:
        comp_plan = plan
        print_info(f"✅ 通过component_code匹配成功")
        break
```

---

### 方案2：改进Agent 1提示词（中期方案）

**问题**：Agent 1没有明确告知"base_part必须是BOM表的第1行"

**改进提示词**：

```python
## ⚠️ 关键约束

**base_part_code的选择规则**：
1. **必须从组件图的BOM表中选择**
2. **优先选择BOM表的第1行零件**（因为后续匹配逻辑依赖这个假设）
3. 如果第1行零件不是最重的，也要选第1行（确保匹配成功）
4. 在assembly_steps中可以说明"虽然第1行不是最重，但作为基准件"

**示例**：
组件图1的BOM表：
- 第1行：01.01.03.0693, 方管, 7.34kg
- 第2行：01.01.03.0692, 方管, 26.16kg

正确的base_part_code应该是：`01.01.03.0693`（第1行）
而不是：`01.01.03.0692`（第2行，虽然更重）
```

---

### 方案3：增加BOM提取质量检查（长期方案）

**在Step 2（BOM提取）后，增加质量检查**：

```python
def check_bom_quality(bom_data, file_hierarchy):
    """检查BOM数据质量"""
    issues = []
    
    # 检查每个组件图是否有BOM数据
    for comp in file_hierarchy.get("components", []):
        comp_name = comp.get("name")
        comp_bom = [item for item in bom_data if item.get("source_pdf") == comp_name]
        
        if len(comp_bom) == 0:
            issues.append(f"⚠️ {comp_name} 没有BOM数据")
        elif len(comp_bom) < 3:
            issues.append(f"⚠️ {comp_name} 只有 {len(comp_bom)} 个零件（可能不完整）")
    
    return issues
```

**如果发现问题，提示用户**：
```
⚠️ BOM数据质量检查发现问题：
- 组件图3.PDF 没有BOM数据
- 组件图4.PDF 只有 4 个零件（可能不完整）

建议：
1. 检查图纸质量（是否清晰、是否有BOM表）
2. 重新上传图纸
3. 或手动输入BOM数据
```

---

## 🚀 立即行动计划

### 优先级1：修复匹配逻辑（今天完成）

1. 修改 `core/hierarchical_bom_matcher_v2.py` 的匹配逻辑
2. 实现"多候选匹配"策略
3. 添加详细的日志输出（显示匹配过程）

### 优先级2：改进Agent 1提示词（明天完成）

1. 修改 `prompts/agent_1_vision_planning.py`
2. 明确base_part选择规则
3. 增加示例说明

### 优先级3：增加质量检查（本周完成）

1. 在 `core/gemini_pipeline.py` 的Step 2后增加质量检查
2. 发现问题时给用户明确提示
3. 提供重新上传或手动修正的选项

---

## 📊 预期效果

**修复后**：
- ✅ 组件图1、2、4 能够成功匹配
- ✅ 组件图3 会提示"BOM数据缺失，请检查图纸"
- ✅ 组件级别处理完成：3个组件（1、2、4）
- ✅ 用户能清楚知道哪里出了问题

**长期效果**：
- 匹配成功率从 0% 提升到 80%+
- 用户体验大幅改善（有明确的错误提示）
- 减少"黑盒"错误（用户不知道为什么失败）

