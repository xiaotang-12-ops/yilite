
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>T-SPV1830-EURO Â· 3Dè£…é…ä¸è¿åŠ¨ç¤ºæ„ (ESM / Three.js)</title>
<style>
  :root { --bg:#0b1020; --fg:#e5e7eb; --muted:#9ca3af; --accent:#22d3ee; --accent2:#a78bfa; }
  *{box-sizing:border-box}
  body{margin:0; background:radial-gradient(800px 600px at 70% 20%, rgba(34,211,238,.08), transparent), #0b1020; color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  header{padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.08);}
  h1{font-size:18px; margin:0 0 4px 0;}
  .sub{font-size:12px; color:var(--muted)}
  .wrap{display:grid; grid-template-columns: 320px 1fr; gap:12px; padding:12px;}
  .panel{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:12px;}
  .panel h2{font-size:13px; margin:0 0 8px; color:var(--muted)}
  #viewport{height:78vh; border-radius:14px; overflow:hidden; border:1px solid rgba(255,255,255,.08);}
  .row{display:grid; grid-template-columns: 1fr auto; align-items:center; gap:10px; margin:8px 0;}
  .ctrls button{padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--fg); cursor:pointer; font-weight:600;}
  .ctrls button:hover{background:rgba(255,255,255,.12)}
  .note{font-size:12px; color:#cbd5e1; margin-top:8px;}
  .legend{display:grid; gap:6px; font-size:12px; color:var(--muted); margin-top:6px;}
  .legend div{display:flex; align-items:center; gap:8px;}
  .dot{width:10px; height:10px; border-radius:50%;}
  .d-base{background:#60a5fa}
  .d-link{background:#34d399}
  .d-bladeL{background:#f472b6}
  .d-bladeR{background:#f59e0b}
  .d-cyl{background:#22d3ee}
  .d-spring{background:#eab308}
  .d-wheel{background:#a78bfa}
  input[type=range]{width:100%}
</style>
</head>
<body>
<header>
  <h1>T-SPV1830-EURO Vå‹æ¨é›ªæ¿ Â· 3Dè£…é…ç¤ºæ„ï¼ˆES Moduleç‰ˆï¼‰</h1>
  <div class="sub">åä¹‰æ€»å®½ 1830mmã€å·¦å³æ ‡æ³¨ 28Â°ã€å¼€åˆæ¼”ç¤º ~50Â°ï¼ˆÂ±25Â°ï¼‰ã€‚æ³¨æ„ï¼šæ­¤ä¸ºè¿‘ä¼¼å‚æ•°åŒ–ï¼›éœ€ä¸¥è°¨å¤åŸè¯·æä¾›å®Œæ•´å°ºå¯¸/å…¬å·®ã€‚</div>
</header>
<div class="wrap">
  <aside class="panel">
    <h2>å‚æ•° & æ§åˆ¶</h2>
    <div class="row"><div>å¼€åˆè§’ï¼ˆå•ä¾§ï¼ŒÂ°ï¼‰</div><div id="angleVal">0</div></div>
    <input id="angle" type="range" min="-25" max="25" step="0.1" value="0" />
    <div class="row"><div>çˆ†ç‚¸è§†å›¾ï¼ˆ%ï¼‰</div><div id="explodeVal">0</div></div>
    <input id="explode" type="range" min="0" max="100" step="1" value="0" />
    <div class="ctrls" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
      <button id="btnPlay">â–¶ å¼€åˆåŠ¨ç”»</button>
      <button id="btnStop">â¸ åœæ­¢</button>
      <button id="btnReset">âŸ² é‡ç½®è§†å›¾</button>
      <button id="btnExplode">ğŸ’¥ å±•å¼€/åˆæ‹¢</button>
      <button id="btnWire">ğŸ§µ çº¿æ¡†åˆ‡æ¢</button>
    </div>

    <div class="legend">
      <div><span class="dot d-base"></span> -01 è¿æ¥å™¨ååº§ç»„ä»¶ï¼ˆéª¨æ¶ï¼‰</div>
      <div><span class="dot d-link"></span> -02 ååº§è¿æ¥æ¶ï¼ˆæ¢çº½ï¼‰</div>
      <div><span class="dot d-bladeL"></span> -03 å·¦é“²é›ªæ¿ç»„ä»¶</div>
      <div><span class="dot d-bladeR"></span> -04 å³é“²é›ªæ¿ç»„ä»¶ï¼ˆå¯¹ç§°ï¼‰</div>
      <div><span class="dot d-cyl"></span> æ²¹ç¼¸ï¼ˆÃ—2ï¼Œè¡Œç¨‹ç¤ºæ„ï¼‰</div>
      <div><span class="dot d-spring"></span> å‹ç¼©å¼¹ç°§ï¼ˆÃ—6ï¼Œç¤ºæ„ï¼‰</div>
      <div><span class="dot d-wheel"></span> è½®æ¶/è½®å­ï¼ˆÃ—2ï¼Œç¤ºæ„ï¼‰</div>
    </div>

    <div class="note">
      æœ¬é¡µä»¥ ES Modules æ–¹å¼åŠ è½½ Three.jsã€‚è¯·ç”¨æœ¬åœ°æœåŠ¡å™¨è®¿é—®ï¼ˆå¦‚ <code>python -m http.server 8000</code>ï¼‰ï¼Œåœ¨æµè§ˆå™¨æ‰“å¼€ <code>http://localhost:8000/assembly_3d_esm.html</code>ã€‚
    </div>
  </aside>

  <main class="panel">
    <div id="viewport"></div>
  </main>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

  const viewport = document.getElementById('viewport');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1020);

  const camera = new THREE.PerspectiveCamera(50, viewport.clientWidth / viewport.clientHeight, 0.1, 5000);
  camera.position.set(0, 350, 1200);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(viewport.clientWidth, viewport.clientHeight);
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
  viewport.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 100, 0);
  controls.update();

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(500, 800, 400);
  scene.add(dir);

  // Ground grid
  const grid = new THREE.GridHelper(4000, 40, 0x223344, 0x1b2736);
  grid.position.y = 0;
  scene.add(grid);

  const group = new THREE.Group();
  scene.add(group);

  // Scale: 1 unit = 1 mm
  const totalWidth = 1830;
  const bladeHeight = 300;
  const bladeThickness = 20;
  const baseWidth = 900, baseDepth = 80, baseHeight = 80;
  const linkPlate = {w:120, h:120, t:30};
  const wheelDia = 200, wheelWidth = 50;
  const bladeOffsetY = 100;

  const materials = {
    base:   new THREE.MeshPhysicalMaterial({color:0x60a5fa, metalness:.4, roughness:.6}),
    link:   new THREE.MeshPhysicalMaterial({color:0x34d399, metalness:.3, roughness:.7}),
    bladeL: new THREE.MeshPhysicalMaterial({color:0xf472b6, metalness:.2, roughness:.7}),
    bladeR: new THREE.MeshPhysicalMaterial({color:0xf59e0b, metalness:.2, roughness:.7}),
    cyl:    new THREE.MeshPhysicalMaterial({color:0x22d3ee, metalness:.5, roughness:.4}),
    spring: new THREE.MeshPhysicalMaterial({color:0xeab308, metalness:.2, roughness:.5}),
    wheel:  new THREE.MeshPhysicalMaterial({color:0xa78bfa, metalness:.2, roughness:.6}),
  };

  // Base (-01)
  const base = new THREE.Group(); group.add(base);
  const baseBeam = new THREE.Mesh(new THREE.BoxGeometry(baseWidth, baseHeight, baseDepth), materials.base);
  baseBeam.position.set(0, 100, 0);
  base.add(baseBeam);
  const basePlateL = new THREE.Mesh(new THREE.BoxGeometry(140, 30, 60), materials.base);
  basePlateL.position.set(-320, 130, 0); base.add(basePlateL);
  const basePlateR = basePlateL.clone(); basePlateR.position.x = 320; base.add(basePlateR);

  // Link (-02)
  const link = new THREE.Group(); group.add(link);
  const linkCenter = new THREE.Mesh(new THREE.BoxGeometry(linkPlate.w, linkPlate.h, linkPlate.t), materials.link);
  linkCenter.position.set(0, 120, 0);
  link.add(linkCenter);
  const linkSideL = new THREE.Mesh(new THREE.BoxGeometry(200, 40, 30), materials.link);
  linkSideL.position.set(-200, 110, 0); link.add(linkSideL);
  const linkSideR = linkSideL.clone(); linkSideR.position.x = 200; link.add(linkSideR);

  // Blades (-03/-04) approximate profile
  function createBlade(material, mirror=false){
    const shape = new THREE.Shape();
    const w = totalWidth/2 + 80;
    const h = bladeHeight;
    shape.moveTo(0,0);
    shape.bezierCurveTo(w*0.25, -h*0.6, w*0.6, -h*0.6, w, 0);
    shape.lineTo(w, h*0.7);
    shape.bezierCurveTo(w*0.6, h*0.9, w*0.25, h*0.9, 0, h*0.7);
    shape.lineTo(0,0);
    const geo = new THREE.ExtrudeGeometry(shape, {depth: bladeThickness, bevelEnabled:false, steps:20});
    geo.center();
    const mesh = new THREE.Mesh(geo, material);
    mesh.rotation.x = -Math.PI/2;
    if(mirror){ mesh.scale.x *= -1; }
    mesh.scale.set(0.75, 1.0, 1.0);
    return mesh;
  }

  const pivotL = new THREE.Group(); group.add(pivotL);
  pivotL.position.set(-200, bladeOffsetY, 0);
  const bladeL = createBlade(materials.bladeL, false);
  pivotL.add(bladeL);

  const pivotR = new THREE.Group(); group.add(pivotR);
  pivotR.position.set(200, bladeOffsetY, 0);
  const bladeR = createBlade(materials.bladeR, true);
  pivotR.add(bladeR);

  // Cutting edge (simple rectangular strip)
  const edgeMatL = new THREE.MeshPhysicalMaterial({color:0xbe185d, metalness:.2, roughness:.6});
  const edgeMatR = new THREE.MeshPhysicalMaterial({color:0xb45309, metalness:.2, roughness:.6});
  const edgeL = new THREE.Mesh(new THREE.BoxGeometry(800, 12, 40), edgeMatL);
  edgeL.position.set(100, -5, 0);
  bladeL.add(edgeL);
  const edgeR = new THREE.Mesh(new THREE.BoxGeometry(800, 12, 40), edgeMatR);
  edgeR.position.set(-100, -5, 0);
  bladeR.add(edgeR);

  // Cylinders (approx) between link and blades
  function createCylinderBar(x1,y1,z1, x2,y2,z2){
    const start = new THREE.Vector3(x1,y1,z1);
    const end   = new THREE.Vector3(x2,y2,z2);
    const dirV = new THREE.Vector3().subVectors(end, start);
    const len = dirV.length();
    const geo = new THREE.CylinderGeometry(8,8,len,12);
    const mesh = new THREE.Mesh(geo, materials.cyl);
    const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
    mesh.position.copy(mid);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dirV.clone().normalize());
    return mesh;
  }
  let cylL = createCylinderBar(-20,110,0, -260, bladeOffsetY+10, 0);
  let cylR = createCylinderBar( 20,110,0,  260, bladeOffsetY+10, 0);
  scene.add(cylL, cylR);

  // Springs (simple boxes as placeholders)
  const springs = new THREE.Group(); group.add(springs);
  function springBox(x,y,z){ const m=new THREE.Mesh(new THREE.BoxGeometry(80,16,16), materials.spring); m.position.set(x,y,z); return m; }
  springs.add(springBox(-360, bladeOffsetY+40, 40));
  springs.add(springBox(-300, bladeOffsetY+65, 20));
  springs.add(springBox(-240, bladeOffsetY+90, 0));
  springs.add(springBox( 360, bladeOffsetY+40,-40));
  springs.add(springBox( 300, bladeOffsetY+65,-20));
  springs.add(springBox( 240, bladeOffsetY+90,  0));

  // Wheels
  function createWheel(x,y,z){
    const t = new THREE.Mesh(new THREE.CylinderGeometry(wheelDia/2, wheelDia/2, wheelWidth, 32), materials.wheel);
    t.position.set(x,y,z); t.rotation.z = Math.PI/2;
    return t;
  }
  const wheelL = createWheel(-350, 60, 0);
  const wheelR = createWheel( 350, 60, 0);
  scene.add(wheelL, wheelR);

  // Explode control
  const explode = document.getElementById('explode');
  const explodeVal = document.getElementById('explodeVal');
  function applyExplode(v){
    explodeVal.textContent = v;
    base.position.set(0, 0, 0);
    link.position.set(0, v*0.8, 0);
    pivotL.position.set(-200 - v*1.2, bladeOffsetY + v*0.4, -v*0.6);
    pivotR.position.set( 200 + v*1.2, bladeOffsetY + v*0.4,  v*0.6);
    cylL.position.z = -v*0.4;
    cylR.position.z =  v*0.4;
    springs.position.y = bladeOffsetY + 20 + v*0.5;
    wheelL.position.z = -v*0.5;
    wheelR.position.z =  v*0.5;
  }
  explode.addEventListener('input', e=>applyExplode(parseFloat(e.target.value)));

  // Open/close control
  const angle = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  function applyAngle(aDeg){
    angleVal.textContent = aDeg.toFixed(1);
    const rad = THREE.MathUtils.degToRad(aDeg);
    pivotL.rotation.y =  rad;
    pivotR.rotation.y = -rad;
    // recompute cylinders
    scene.remove(cylL, cylR);
    const leftTip = new THREE.Vector3().setFromMatrixPosition(pivotL.matrixWorld);
    const rightTip = new THREE.Vector3().setFromMatrixPosition(pivotR.matrixWorld);
    cylL = createCylinderBar(-20,110,0, leftTip.x-60*Math.cos(rad), bladeOffsetY+10, leftTip.z-60*Math.sin(rad));
    cylR = createCylinderBar( 20,110,0, rightTip.x+60*Math.cos(rad), bladeOffsetY+10, rightTip.z+60*Math.sin(rad));
    scene.add(cylL, cylR);
  }
  angle.addEventListener('input', e=>applyAngle(parseFloat(e.target.value)));

  // Wireframe toggle
  const btnWire = document.getElementById('btnWire');
  let wireOn = false;
  btnWire.addEventListener('click', ()=>{
    wireOn = !wireOn;
    [base, link, pivotL, pivotR, springs, wheelL, wheelR].forEach(g=>{
      g.traverse(obj=>{ if(obj.isMesh){ obj.material.wireframe = wireOn; }});
    });
    [cylL, cylR].forEach(m=>{ m.material.wireframe = wireOn; });
  });

  // Play/stop and reset
  const btnPlay = document.getElementById('btnPlay');
  const btnStop = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const btnExplode = document.getElementById('btnExplode');

  let playing = false, t0 = 0;
  btnPlay.addEventListener('click', ()=>{ playing = true; t0 = performance.now(); });
  btnStop.addEventListener('click', ()=>{ playing = false; });
  btnReset.addEventListener('click', ()=>{
    playing = false;
    camera.position.set(0,350,1200); controls.target.set(0,100,0); controls.update();
    applyAngle(0); angle.value = 0; angle.dispatchEvent(new Event('input'));
    applyExplode(0); explode.value = 0; explode.dispatchEvent(new Event('input'));
  });
  btnExplode.addEventListener('click', ()=>{
    const v = parseFloat(explode.value);
    const target = v>0 ? 0 : 100;
    let start = null;
    function anima(ts){
      if(!start) start = ts;
      const t = Math.min(1, (ts - start) / 600);
      const cur = v + (target - v) * t;
      explode.value = cur.toFixed(1);
      applyExplode(cur);
      if(t<1) requestAnimationFrame(anima);
    }
    requestAnimationFrame(anima);
  });

  function animate(ts){
    requestAnimationFrame(animate);
    if(playing){
      const a = (ts - t0) / 3000; // 3s period
      const deg = Math.sin(a*2*Math.PI) * 25;
      angle.value = deg.toFixed(2);
      applyAngle(deg);
    }
    renderer.render(scene, camera);
  }
  // init
  applyAngle(0);
  applyExplode(0);
  animate();

  window.addEventListener('resize', ()=>{
    const W2 = viewport.clientWidth;
    const H2 = viewport.clientHeight;
    camera.aspect = W2/H2; camera.updateProjectionMatrix();
    renderer.setSize(W2,H2);
  });
</script>
</body>
</html>
