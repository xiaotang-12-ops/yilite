---
type: "manual"
---

我收到了你的需求！让我先检索项目的当前架构，然后进行深度分析。





现在让我检查一下核心处理流程和提示词文件：









现在让我深入分析处理流程和数据流：





































## 【我的理解】

小糖，我已经完成了深度分析。让我先说明我理解的你的需求：

你遇到的问题是**当产品总图包含大量图片时，程序会崩溃**，你想通过**分阶段上传策略**来解决：
1. 第一阶段：先上传子组件图纸
2. 第二阶段：再上传产品总图

你希望我分析这个方案的可行性、需要修改哪些模块、是否有更优方案。

---

## 【深度分析结果】

### 一、问题根源诊断 🔍

通过分析代码，我发现**真正的问题根源**不是业务逻辑，而是**技术实现层面的内存管理问题**：

#### 当前PDF处理流程的致命缺陷：

```python
# core/gemini_pipeline.py 第349行
pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))  # 2倍缩放！
img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
```

**问题分析**：
- 工程图纸通常是A0或A1尺寸（841mm × 1189mm）
- 2倍缩放后：约 **6600px × 9400px**
- 单张图片内存占用：6600 × 9400 × 3 bytes ≈ **186MB**（未压缩）
- 如果产品总图有10页：10 × 186MB = **1.86GB**
- 再加上3个组件图（每个5页）：15 × 186MB = **2.79GB**
- **总内存占用：4.65GB**（仅图片数据）

这就是程序崩溃的真正原因！

---

### 二、你提出的"分阶段上传"方案评估 📊

#### ✅ 技术可行性：**可行**

**需要修改的模块**：

| 模块 | 修改内容 | 工作量 |
|------|---------|--------|
| **前端上传逻辑** | 添加两阶段上传UI，状态管理 | 中等（3-5天） |
| **后端API** | 新增 `/api/upload-components` 和 `/api/upload-product` | 中等（2-3天） |
| **Agent 1提示词** | 拆分为 `component_only_prompt` 和 `product_only_prompt` | 较大（5-7天） |
| **Pipeline流程** | 添加 `process_components_only()` 和 `process_product_only()` | 较大（5-7天） |
| **数据存储** | 存储中间状态（第一阶段结果） | 小（1天） |

**总工作量**：**2-3周**

#### ⚠️ 业务逻辑适配性：**部分适配**

**当前Agent 1的设计逻辑**：
- 需要**同时看到产品总图和所有组件图**
- 从产品总图识别组件序号（①、②、③）
- 从组件图识别每个组件内部的零件序号
- 建立"产品总图序号 ↔ 组件BOM代号 ↔ 组件图"的映射关系

**改造后的逻辑**：
- **第一阶段**：只处理组件图 → 输出每个组件的内部装配步骤
- **第二阶段**：处理产品总图 → 输出组件间的装配顺序
- **整合阶段**：合并两阶段结果

**关键点**：两个阶段可以**独立处理**，因为：
- 组件内部装配步骤不依赖产品总图
- 组件间装配顺序不依赖组件图的细节

#### 🎯 解决根本问题：**可以，但不是最优方案**

分阶段上传可以减少单次处理的图片数量，但：
- 如果单个产品总图本身有30页，第二阶段仍然会崩溃
- 没有解决"图片分辨率过高"的根本问题

---

### 三、潜在风险和边界情况 ⚠️

| 风险 | 场景 | 缓解措施 |
|------|------|---------|
| **BOM代号不一致** | 组件图代号"01.09.1140"，产品总图写"01.09.1140-A" | 第二阶段做模糊匹配（前缀匹配） |
| **只上传组件图** | 用户不需要产品级装配 | 第二阶段设为可选 |
| **上传顺序错误** | 先上传产品总图 | 前端强制顺序或后端自动识别 |
| **组件数量不确定** | 可能有3个或10个组件 | 前端添加"完成组件上传"按钮 |
| **第一阶段失败** | 某个组件图处理失败 | 允许跳过失败的组件 |

---

### 四、更优的替代方案 🚀

#### **推荐方案（按优先级排序）**：

#### [object Object]：图片优化 + 分页处理（立即实施）**

**核心改动**：
```python
# 修改 core/gemini_pipeline.py 第349行
# 原代码：
pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))  # 2倍缩放

# 改为：
pix = page.get_pixmap(matrix=fitz.Matrix(1.2, 1.2))  # 1.2倍缩放

# 并添加JPEG压缩：
img.save(buffered, format="JPEG", quality=85)  # 代替PNG
```

**效果对比**：
- **优化前**：单页186MB × 10页 = 1.86GB
- **优化后**：单页约5MB × 10页 = **50MB**（减少97%）

**优点**：
- ✅ 工作量极小（1-2天）
- ✅ 可以处理20-30页的PDF
- ✅ 不改变业务逻辑
- ✅ 立即见效

**缺点**：
- ⚠️ 可能影响OCR准确率（需要测试）

---[object Object]方案2：异步队列处理（短期优化）**

**实施方案**：
- 使用Celery/RQ任务队列
- 前端上传后立即返回task_id
- 后端异步处理，前端轮询进度

**优点**：
- ✅ 用户体验好，不会卡死
- ✅ 支持长时间任务
- ✅ 可以和方案1结合

**工作量**：3-5天

---[object Object]方案3：两阶段处理（长期规划）**

**就是你提出的方案**，适用于极端情况（100页以上PDF）。

**实施路径**：
1. **第一阶段开发**（1周）：
   - 修改前端：添加"上传组件图"和"上传产品总图"两个入口
   - 修改后端：添加 `/api/upload-components` 接口
   - 修改Agent 1：创建 `component_only_prompt`

2. **第二阶段开发**（1周）：
   - 修改后端：添加 `/api/upload-product` 接口
   - 修改Agent 1：创建 `product_only_prompt`
   - 修改Pipeline：添加两阶段处理逻辑

3. **整合与测试**（3-5天）：
   - 测试两阶段结果的合并
   - 测试边界情况（只上传组件图、BOM代号不匹配等）

**工作量**：2-3周

---

### 五、最终结论与[object Object]结论**：
1. ✅ 你提出的"分阶段上传"方案**技术可行**
2. ⚠️ 但**不是最优方案**，因为没有解决根本问题（图片分辨率过高）
3. 🎯 **真正的问题**是代码中使用了2倍缩放，导致内存占用过大

#### **我的建议**：

**立即实施（本周）**：
- ✅ **方案1**：降低图片缩放倍数（2倍 → 1.2倍）+ JPEG压缩
- ✅ 添加内存监控和错误日志，定位具体崩溃点

**短期优化（下周）**：
- ✅ **方案2**：添加异步队列处理，改善用户体验

**长期规划（如果方案1+2仍不够）**：
- ✅ **方案3**：实施你提出的两阶段上传方案

---

### 需要注意的是...

1. **测试是关键**：方案1修改后，必须用真实的工程图纸测试OCR准确率
2. **监控内存占用**：添加日志记录每个步骤的内存占用，精确定位问题
3. **渐进式优化**：先实施简单方案，如果不够再升级到复杂方案

### 边界信息/灵感火花...

- 如果你的工程图纸是**矢量PDF**（不是扫描件），可以考虑直接提取文本和矢量图形，而不是转图片
- 可以使用**PDF裁剪**技术，只提取BOM表区域和3D视图区域，忽略其他空白区域
- 考虑使用**流式处理**：边读边处理边释放内存，而不是一次性加载所有图片

---

**小糖，我的分析完成了。你希望我：**
1. 立即实施方案1（图片优化）？
2. 还是按照你原来的想法，开发方案3（两阶段上传）？
3. 或者你想先看看当前代码的实际内存占用情况？

请告诉我你的决定，我会立即开始实施！🚀