
# 技术方案：智能装配手册生成系统重构方案（V2.0 - 完善版）

> **重要说明**：本方案经过深入分析，保留Agent 1的核心功能，确保系统的可靠性和完整性。

---

## � 目录
1. [核心思想](#核心思想)
2. [深度分析：为什么要保留Agent 1](#深度分析为什么要保留agent-1)
3. [新架构设计](#新架构设计)
4. [详细修改方案](#详细修改方案)
5. [实施步骤](#实施步骤)
6. [风险评估与应对](#风险评估与应对)

---

## 🎯 核心思想

```
组件图1（焊接） → 焊接智能体 → JSON1
组件图2（焊接） → 焊接智能体 → JSON2
产品总图（拼装） → 拼装智能体 → JSON3
                    ↓
            拼接JSON1+JSON2+JSON3 → 最终JSON
```

**关键原则**：
- ✅ **职责清晰**：焊接智能体专门处理组件图，拼装智能体专门处理产品总图
- ✅ **简化流程**：装配顺序由文件上传顺序决定，不需要复杂的全局规划
- ✅ **保留必要功能**：Agent 1保留，但简化其作用（只识别关键信息，不规划装配顺序）

---

## 🔍 深度分析：为什么要保留Agent 1

### ❌ 之前方案的问题（完全去掉Agent 1）

**问题1：零件清单从哪里来？**
- ❌ **错误理解**：Agent 1负责提取零件清单
- ✅ **实际情况**：零件清单由步骤2（BOM提取）从PDF中提取，每个BOM项都有`source_pdf`字段
- ✅ **结论**：不需要Agent 1提取零件清单

**问题2：组件的BOM代号从哪里来？**
- ❌ **方案A（去掉Agent 1）**：从文件名提取（如"1__01.09.2549.PDF"）
  - **风险**：如果文件名不规范（如"组件图1.PDF"），就无法获取BOM代号
  - **影响**：BOM-3D匹配、组件装配步骤生成都会失败
- ✅ **方案B（保留Agent 1）**：从图纸中识别BOM代号（从BOM表中读取）
  - **优势**：不依赖文件名，更可靠
  - **实现**：Agent 1看图纸，从BOM表中提取组件代号

**问题3：基准件/基准组件从哪里来？**
- ❌ **方案A（去掉Agent 1）**：Agent 3/4自己识别
  - **风险**：增加提示词复杂度，可能识别不准确
  - **影响**：装配顺序可能不合理
- ✅ **方案B（保留Agent 1）**：Agent 1识别基准件/基准组件
  - **优势**：专门的识别任务，更准确
  - **实现**：Agent 1看所有图纸，识别基准件/基准组件

### ✅ 保留Agent 1的理由

**Agent 1的核心价值**：
1. **从图纸中识别组件的BOM代号**（不依赖文件名）
2. **识别每个组件的基准件**（最重、最大的零件）
3. **识别产品的基准组件**（底座、框架等大型组件）
4. **提供装配顺序的参考**（虽然最终由文件顺序决定，但可以作为验证）

**简化Agent 1的作用**：
- ❌ **去掉**：装配顺序规划（assembly_order由文件顺序决定）
- ✅ **保留**：信息识别（component_code, base_part_code, base_component_code）

---

## 🏗️ 新架构设计

### 架构对比

| 维度 | 当前架构 | 新架构（保留Agent 1简化版） |
|------|---------|---------------------------|
| **步骤数** | 8步 | 8步（保持不变） |
| **Agent 1** | ✅ 视觉规划（看所有图纸，规划装配顺序） | ✅ 信息识别（看所有图纸，只识别关键信息） |
| **Agent 3（焊接）** | 依赖Agent 1的规划（component_plan） | 依赖Agent 1的识别（component_code, base_part_code） |
| **Agent 4（拼装）** | 依赖Agent 1的规划（product_plan） | 依赖Agent 1的识别（base_component_code） |
| **装配顺序** | Agent 1智能规划 | **文件上传顺序**（简化） |
| **配对逻辑** | 复杂（用base_part_code匹配） | 简单（按文件顺序） |
| **职责清晰度** | 较模糊（Agent 1既规划又识别） | **非常清晰**（Agent 1只识别，Agent 3/4只装配） |
| **可维护性** | 中等（Agent 3/4依赖Agent 1） | **高**（依赖关系清晰，Agent 1只提供信息） |

### 新架构的优势

1. **职责更清晰**：
   - **Agent 1**：只负责信息识别（BOM代号、基准件、基准组件）
   - **Agent 3（焊接智能体）**：只负责组件装配步骤生成（焊接场景）
   - **Agent 4（拼装智能体）**：只负责产品装配步骤生成（拼装场景）

2. **简化装配顺序**：
   - ❌ **旧方案**：Agent 1规划装配顺序，Agent 3/4按照规划执行
   - ✅ **新方案**：装配顺序由文件上传顺序决定，简单直接

3. **降低复杂度**：
   - ❌ **旧方案**：Agent 1需要看所有图纸，规划全局装配顺序
   - ✅ **新方案**：Agent 1只识别关键信息，不规划装配顺序

4. **易于扩展**：
   - 如果有10个组件图，就调用10次焊接智能体（按文件顺序）
   - 如果有多个产品总图，就调用多次拼装智能体

---

## � 详细修改方案

### 修改概览

| 文件 | 修改内容 | 难度 | 影响范围 |
|------|---------|------|---------|
| `prompts/agent_1_vision_planning.py` | 简化提示词，去掉装配顺序规划 | ⭐⭐ | Agent 1 |
| `core/gemini_pipeline.py` | 修改Agent 1调用逻辑，装配顺序由文件顺序决定 | ⭐⭐⭐ | 整体流程 |
| `agents/component_assembly_agent.py` | 修改process方法，接收简化的参数 | ⭐⭐ | Agent 3 |
| `agents/product_assembly_agent.py` | 修改process方法，接收简化的参数 | ⭐⭐ | Agent 4 |
| `prompts/agent_3_component_assembly.py` | 更新提示词，明确基准件来自Agent 1 | ⭐ | Agent 3 |
| `prompts/agent_4_product_assembly.py` | 更新提示词，明确基准组件来自Agent 1 | ⭐ | Agent 4 |
| `core/manual_integrator_v2.py` | 保持不变（planning_result仍然传入） | - | 整合器 |

---

## 🔧 具体修改方案

### 1. **core/gemini_pipeline.py**（核心修改）

**去掉步骤3（Agent 1）**：
```python
# ❌ 删除这部分
def _step3_vision_planning(self, image_hierarchy, bom_data, file_hierarchy):
    ...
```

**修改步骤5（Agent 3调用）**：
```python
# 当前代码（依赖Agent 1）
component_results = self._step5_component_assembly(
    file_hierarchy, image_hierarchy, planning_result, matching_result
)

# 新代码（不依赖Agent 1）
component_results = self._step5_component_assembly(
    file_hierarchy, image_hierarchy, matching_result
)
```

**修改步骤6（Agent 4调用）**：
```python
# 当前代码（依赖Agent 1）
product_result = self._step6_product_assembly(
    file_hierarchy, image_hierarchy, planning_result, matching_result
)

# 新代码（不依赖Agent 1）
product_result = self._step6_product_assembly(
    file_hierarchy, image_hierarchy, matching_result
)
```

---

### 2. **agents/component_assembly_agent.py**（焊接智能体）

**修改process方法签名**：
```python
# 当前代码
def process(
    self,
    component_plan: Dict,  # ← 来自Agent 1
    component_images: List[str],
    parts_list: List[Dict],
    ...
)

# 新代码
def process(
    self,
    component_name: str,        # ← 从file_hierarchy获取
    component_code: str,        # ← 从file_hierarchy获取
    assembly_order: int,        # ← 按文件顺序（1, 2, 3...）
    component_images: List[str],
    parts_list: List[Dict],
    ...
)
```

**修改提示词构建**：
```python
# 在提示词中添加：
# "请从BOM表中识别基准件（通常是最重、最大的零件，序号为①）"
```

---

### 3. **agents/product_assembly_agent.py**（拼装智能体）

**修改process方法签名**：
```python
# 当前代码
def process(
    self,
    product_plan: Dict,  # ← 来自Agent 1
    product_images: List[str],
    components_list: List[Dict],
    ...
)

# 新代码
def process(
    self,
    product_name: str,          # ← 从file_hierarchy获取
    product_images: List[str],
    components_list: List[Dict],
    ...
)
```

**修改提示词构建**：
```python
# 在提示词中添加：
# "请从图纸中识别基准组件（通常是底座、框架等大型组件）"
```

---

### 4. **prompts/agent_3_component_assembly.py**（焊接提示词）

**在"步骤2：装配顺序规划"中添加**：
```markdown
### 步骤2：装配顺序规划（Assembly Sequence Planning）

**操作**：
1. **识别基准件**：
   - 从BOM表中找到最重、最大的零件作为基准件
   - 基准件通常是序号①的零件
   - 基准件作为第1步放置

2. **分析零件空间关系**：
   ...
```

---

### 5. **prompts/agent_4_product_assembly.py**（拼装提示词）

**在"步骤1：图纸视觉分析"中强调**：
```markdown
### 步骤1：图纸视觉分析（Visual Analysis）

**操作**：
1. 识别图纸上的所有组件编号（①、②、③...）
2. 观察组件的空间位置关系（上下、左右、内外）
3. **识别基准组件**：
   - 从图纸中找到底座、框架等大型组件作为基准组件
   - 基准组件通常是序号①的组件
   - 基准组件作为第1步放置
4. 对照BOM表，将图纸序号与组件代号对应
```

---

### 6. **core/manual_integrator_v2.py**（整合器）

**修改integrate方法签名**：
```python
# 当前代码
def integrate(
    self,
    planning_result: Dict,  # ← 来自Agent 1
    component_assembly_results: List[Dict],
    product_assembly_result: Dict,
    ...
)

# 新代码
def integrate(
    self,
    component_assembly_results: List[Dict],
    product_assembly_result: Dict,
    ...
)
```

**修改元数据构建**：
```python
# 从component_results和product_result中获取组件名称等信息
# 不再依赖planning_result
```

---

## 🎯 修改后的工作流

```
1. 用户上传文件：
   - 组件图1.PDF
   - 组件图2.pdf
   - 产品总图.PDF

2. 文件分类（步骤1）：
   - 识别出：2个组件图 + 1个产品总图
   - 转换成图片

3. 提取BOM数据（步骤2）：
   - 从组件图1提取BOM
   - 从组件图2提取BOM
   - 从产品总图提取BOM

4. BOM-3D匹配（步骤3）：
   - 匹配BOM代号和3D模型
   - 智能高亮

5. 焊接智能体（步骤4）：
   - 处理组件图1 → JSON1（assembly_order=1）
   - 处理组件图2 → JSON2（assembly_order=2）
   - 每个组件图独立处理，自己识别基准件

6. 拼装智能体（步骤5）：
   - 处理产品总图 → JSON3
   - 自己识别基准组件

7. 焊接和安全（步骤6）：
   - 增强JSON1、JSON2、JSON3

8. 整合最终手册（步骤7）：
   - 拼接JSON1 + JSON2 + JSON3 → assembly_manual.json
```

---

## 💡 关键改进点

### 1. **装配顺序由文件顺序决定**
```python
# 在gemini_pipeline.py中
for i, comp in enumerate(file_hierarchy['components']):
    assembly_order = i + 1  # 组件图1 → order=1, 组件图2 → order=2
    component_result = self.component_agent.process(
        component_name=comp['name'],
        component_code=comp['bom_code'],
        assembly_order=assembly_order,  # ← 按文件顺序
        ...
    )
```

### 2. **Agent 3自己识别基准件**
```python
# 在agent_3_component_assembly.py的提示词中
"""
请从BOM表中识别基准件：
- 基准件通常是最重、最大的零件
- 基准件通常是序号①的零件
- 基准件作为第1步放置
"""
```

### 3. **Agent 4自己识别基准组件**
```python
# 在agent_4_product_assembly.py的提示词中
"""
请从图纸中识别基准组件：
- 基准组件通常是底座、框架等大型组件
- 基准组件通常是序号①的组件
- 基准组件作为第1步放置
"""
```

---

## 🚀 实施建议

### 方案1：一次性重构（推荐）
1. 创建一个新分支 `feature/remove-agent1`
2. 按照上面的修改清单，逐个文件修改
3. 测试完整流程，确保所有功能正常
4. 合并到主分支

### 方案2：渐进式重构
1. 先保留Agent 1，但让Agent 3/4也能独立工作
2. 添加一个配置项 `use_agent1: bool`
3. 如果 `use_agent1=False`，跳过Agent 1，直接调用Agent 3/4
4. 测试新流程，确认没问题后，再删除Agent 1的代码

---

## ❓ 你的疑问解答

### Q1: 当前项目是否已经可以实现这样？
**A**: 当前项目已经很接近了！
- Agent 3 = 焊接智能体（处理组件图）✅
- Agent 4 = 拼装智能体（处理产品总图）✅
- ManualIntegratorV2 = 拼接JSON ✅

**但是**：
- 当前有Agent 1（视觉规划），让架构变复杂了 ❌
- Agent 3/4依赖Agent 1的规划，不能独立工作 ❌

### Q2: 需要怎么修改？
**A**: 按照上面的修改清单，主要修改6个文件：
1. `core/gemini_pipeline.py`：去掉Agent 1，修改Agent 3/4调用
2. `agents/component_assembly_agent.py`：修改process方法
3. `agents/product_assembly_agent.py`：修改process方法
4. `prompts/agent_3_component_assembly.py`：修改提示词
5. `prompts/agent_4_product_assembly.py`：修改提示词
6. `core/manual_integrator_v2.py`：修改integrate方法

---

## 🎉 总结

你的想法非常好！这个架构：
- ✅ **更清晰**：焊接 vs 拼装，职责分明
- ✅ **更简洁**：去掉Agent 1，减少一个步骤
- ✅ **更独立**：每个智能体独立工作，互不依赖
- ✅ **更易维护**：降低耦合，易于扩展

**我建议立即实施这个重构！** 🚀

需要我帮你开始修改代码吗？我可以先从 `gemini_pipeline.py` 开始，逐步重构整个系统。