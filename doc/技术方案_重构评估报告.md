# 技术方案：重构影响评估

## 1. 现状理解

### 1.1 项目与模块概览
- `Memory_Development/project.md:14-100` 描述了现有结构：Vue3 前端、FastAPI 后端、六个 AI Agent 以及 `core/gemini_pipeline.py`、`core/manual_integrator_v2.py` 等核心模块，前端的 `ManualViewer.vue` 是查看器且具备管理员编辑功能。
- API 与产物（上传、生成、输出 JSON/GLB）的契约也在同一文档中说明，决定了前后端协作方式。

### 1.2 当前数据流
- `core/gemini_pipeline.py:507-840` 展示了 8 步流水：步骤1-2预处理；步骤3调用 `VisionPlanningAgent` 生成 `component_assembly_plan` 与 `product_assembly_plan`；步骤4 依赖该规划做 BOM-3D 匹配；步骤5/6 各自把规划结果传给 Agent3/4；步骤7 嵌入焊接/安全；步骤8 借助 `ManualIntegratorV2` 输出 JSON。
- `core/manual_integrator_v2.py:83-210` 依赖 `planning_result` 构建 metadata、按 `assembly_order` 排序组件章节（源自 Agent1 的顺序），并将 task_id 转换为前端可访问的 pdf/GLB 路径。

### 1.3 关键依赖链路
- `core/hierarchical_bom_matcher_v2.py:22-115` 需要 `component_plans` 提供 `component_code`/`base_part_code` 才能把文件系统里的组件序号映射到正确的 AI 规划实体，再输出 `component_level_mappings`。
- `agents/component_assembly_agent.py:44-110` 与 `prompts/agent_3_component_assembly.py:94-120` 依赖 `component_plan` 中的 `component_code/base_part_name/base_part_drawing_number` 作为提示词输入与返回值字段；生成结果仍回写这些字段供后续步骤使用。
- `agents/product_assembly_agent.py:44-105`、`prompts/agent_4_product_assembly.py:581-675` 同样从 `product_plan` 中读取 `assembly_sequence`、基准组件等，参与提示词构建与 JSON 输出。
- 前端 `ManualViewer.vue:714-825` 期望 `component_assembly` 已按 `assembly_order` 排序，并在每个步骤中携带 `drawings`、`glb_file`、`component_code`；`Generator.vue:530-600`、`Viewer.vue:435-452` 直接读取 `manual.metadata.product_name/task_id` 等字段，作为历史记录和删除任务的键。
- `core/file_classifier.py:20-126` 当前仅能通过文件名/序号猜测组件信息（`bom_code` 默认来源于文件名）；若图纸命名不规范会缺少 BOM 代号，因此才需要 Agent1 在图纸内识别真实代号。

## 2. 方案对比分析
- `.augment/技术方案：重构.md:18-107` 提出的核心思想是让装配顺序完全依赖“文件上传顺序”，Agent1 仅保留关键信息识别；焊接/拼装智能体各自独立。
- `.augment/技术方案：重构.md:128-220` 的修改清单却指向“删除 `_step3_vision_planning`，让 Agent3/4 不再接收 `planning_result`，并调整 Agent3/4 的 `process` 签名”。同时 `.augment/技术方案：重构.md:265-291` 又提出 `ManualIntegratorV2.integrate` 不再传入 `planning_result`，但表格又写“保持不变”，方案内部存在矛盾。
- `.augment/技术方案：重构.md:334-369` 进一步强调完全通过 `file_hierarchy['components']` 构建 `assembly_order`、让 Agent3/4 自主识别基准件/基准组件，与现状中“基准件由 Agent1 识别”形成直接冲突。

## 3. 风险识别

### 3.1 代码不可用风险（High）
1. **Pipeline 断裂**：若按 `.augment/技术方案：重构.md:128-160` 删除步骤3，`core/gemini_pipeline.py:562-840` 的后续步骤将拿不到 `component_plans`，导致 BOM-3D 匹配、Agent3/4 调用、ManualIntegrator 元数据构建全部抛异常。这属于现有功能直接瘫痪的风险。
2. **BOM-3D 对齐失败**：`core/hierarchical_bom_matcher_v2.py:69-115` 用 `component_plans` 中的 `component_code/base_part_code` 匹配文件系统。若只剩 `file_hierarchy`，就会退回依赖文件名解析 `bom_code`（`core/file_classifier.py:20-126`），与方案前半部分“不要依赖文件名”自相矛盾，也无法应对非规范命名，直接导致 3D 高亮和 GLB 命名错乱。
3. **Agent3/4 入参缺失**：`agents/component_assembly_agent.py:44-110`、`agents/product_assembly_agent.py:44-105` 目前把 `component_plan/product_plan` 里的基准件、序号、提示语写进 prompt 与返回值。若改成只传 `component_name` 等，`prompts/*` 文件（`prompts/agent_3_component_assembly.py:94-120`、`prompts/agent_4_product_assembly.py:595-675`）必须重写，否则 AI 无法识别基准件，现有 JSON schema 也会缺字段。
4. **前端视图缺口**：`ManualViewer.vue:714-825` 及 `Generator.vue:575-600` 依赖 `manual.metadata.product_name/task_id`、`component_assembly.steps[].drawings`。若 `manual_integrator_v2.integrate` 去掉 `planning_result`（方案 `.augment/技术方案：重构.md:265-291`），这些字段将变为空，前端历史记录与编辑功能都会取不到键值。

### 3.2 缺陷引入风险（Medium-High）
1. **装配顺序与实际工艺不符**：方案要求“按文件上传顺序”作为 `assembly_order`（`.augment/技术方案：重构.md:336-347`），但 `core/file_classifier.py:20-126` 仅根据文件名排序，和图纸上的真实装配顺序/基准件可能不同。3D 高亮及 `ManualViewer` 步骤排序将随上传顺序漂移，极易产生逻辑错误。
2. **自相矛盾的 Agent1 定位**：方案一方面强调“保留 Agent1 的信息识别价值”（`.augment/技术方案：重构.md:60-71`），另一方面又要求彻底删除 `_step3_vision_planning`。若真删除，`component_code/base_part_code/base_component_code` 就无来源；若保留又不让它规划顺序，目前提示词 `prompts/agent_1_vision_planning.py:94-205` 需要大幅调整，方案未提供细节，易造成提示词与代码不一致。
3. **GLB/图片映射错乱**：`core.manual_integrator_v2.py:122-169`、`core.gemini_pipeline.py:877-900` 都用 `assembly_order/drawing_index` 把步骤与 `component_images`、GLB 绑定。若 `assembly_order` 改成上传顺序，而 `drawing_index` 仍取自 BOM 匹配，就可能造成图片与 3D 模型错配，触发不可预测的可视化 bug。

### 3.3 数据兼容性风险（Medium）
1. **历史 JSON 失效**：现有 JSON 中 `metadata.base_component`、`component_assembly[].assembly_order`、`product_assembly.steps[].components/fasteners` 都是前端渲染/编辑的依据（`ManualViewer.vue:714-825`、`Generator.vue:575-600`）。变更结构会让旧历史记录或缓存（localStorage）无法重新加载，缺少迁移策略会丢失管理员编辑的版本。
2. **BOM 覆盖校验逻辑枯竭**：`agents/component_assembly_agent.py:160-210`、`agents/product_assembly_agent.py:97-130` 的覆盖率校验需要 `component_plan/product_plan` 提供零件总数、提示。改成“自识别基准”后，如果 AI 误识别零件数量，就可能通过错误的覆盖率，导致历史数据和新数据难以对齐。

### 3.4 接口/对外契约风险（Medium）
- API `/api/manual/{task_id}` 返回的 JSON 结构和 `3d_resources` 内嵌的路径，都由 `ManualIntegratorV2` 生成（`core/manual_integrator_v2.py:56-210`）。方案若去掉 `planning_result` 输入或调整步骤字段，未同步修改前端/历史 API 文档，会导致第三方或 WebSocket 监听器解析失败。

## 4. 可行性评估
- **技术可行性**：从理论上可以把 `assembly_order` 与 `component_code` 改为由文件系统提供，但需要同步修改 `FileClassifier`、BOM 匹配器、Agent3/4 提示词、ManualIntegrator 以及前端解析逻辑。当前方案没有阐明如何在“文件名不可靠”时仍能得到 `component_code`，也没有说明 Agent4 如何在缺少 `assembly_sequence` 的情况下保持零件/组件去重，自带技术缺口。
- **实施复杂度**：涉及 6 个核心 Python 文件 + 2 个 prompt + ManualIntegrator + 至少两个 Vue 视图（`ManualViewer.vue`、`Generator.vue`）和任何消费 `metadata` 的逻辑，属于系统级重构。还要重新训练/调优提示词来弥补缺失的上下文，测试范围覆盖后端流水线、3D 匹配、前端查看器、管理员编辑、生成 API，工作量高。
- **缺失的细节**：方案未说明
  - 如何在 `file_hierarchy` 丢失 `bom_code` 时 fallback（`core/file_classifier.py:175-179` 仅简单 split `_`）。
  - ManualIntegrator 去掉 `planning_result` 后，`base_component_code`、`task_id`、产品名从哪里来。
  - Agent3/4 提示词如何获取“基准件/组件”，仅一句“请自己识别”无法保证稳定产出。
  - 历史 JSON/GLB 的迁移策略。

## 5. 结论与建议
- **可行性结论**：在不补充额外设计的情况下直接执行该重构，风险等级 **高**。删除 Agent1 或强行让文件顺序决定一切会让当前流水线、BOM-3D 匹配、前端渲染全部失效。

### 建议的行动方案
1. **改为渐进式开关**：采纳方案中“配置 `use_agent1`”的想法（`.augment/技术方案：重构.md:381-385`），在保留 Agent1 的前提下新增按文件顺序的备用路径，通过后端配置切换并 A/B 验证，避免一次性断裂。
2. **补充缺失设计**：在变更前先明确
   - 文件命名不规范时如何生成 `component_code`；
   - Manual JSON schema 的新旧兼容策略；
   - Agent3/4 提示词与 coverage 校验需要的新输入；
   - 前端对 `metadata`、`assembly_order` 的降级显示策略。
3. **验证策略**：构建回归用例，覆盖典型的多组件、多产品图、命名不规范、管理员已编辑的说明书。只有在新旧流水线均能生成同等质量 JSON 后，再考虑移除 Agent1。
4. **风险管控**：在实施前将 `core/manual_integrator_v2.py`、`ManualViewer.vue`、WebSocket 推送等关键路径全部列入回归测试脚本，并确保有自动化检查 `component_assembly.steps[].3d_highlight/parts_used` 的工具，防止“代码不可用”问题上线。

综合来看，建议暂缓一次性重构，优先通过配置化、补齐数据来源与测试策略来降低风险，再逐步裁剪 Agent1 的职责。
