# 智能体重构实施方案（简化：文件顺序驱动）

## 1. 核心原则
1. **人工决定装配顺序**：上传 `组件图1.pdf/组件图1.step` 的就是第 1 个组件，`组件图2` 就是第 2 个，以此类推。系统不再依赖 Agent1 来排顺序。
2. **命名必须规范**：PDF 与 STEP 必须使用完全相同的文件名（仅扩展名不同），并包含“组件图X”或类似格式。命名错误直接拒绝处理。
3. **基准组件仍需识别**：产品总图的“基准组件/底座”依然由智能体识别（可以让 Agent4 自己识别，也可以保留 Agent1 的“基准组件识别”部分）。组件内部的基准件则由焊接智能体根据 BOM 自行判断。
4. **组件基准件固定为序号1**：用户确认组件图内的序号1即基准件，不再需要 AI 判断“最重件”，提示词和校验逻辑都按序号1展开。

## 2. 新流程概览
```
上传文件 → 校验命名&顺序 → 组件图交给焊接智能体 → 产品图交给拼装智能体 → 拼接 JSON → 前端查看/编辑
```

## 3. 实施细则

### 3.1 上传与命名校验
- 在上传接口或 `core/file_classifier.py` 中添加校验：
  - PDF 与 STEP 必须同名（当前已做处理）；
  - Index 不能重复、不能断档（1、2、3…）。
- 校验不通过时直接返回错误，提示用户“命名不符合规范，请按照组件图X命名”。

### 3.2 文件分类
- `core/file_classifier.py`
  - 解析文件名得到 `index` 并写入 `assembly_order`；
  - 将同名 PDF/STEP 绑定到同一个组件；
  - `bom_code` 可以从文件名中提取（若文件名中无 BOM 代号则留空，后续由 BOM 表给出）。

### 3.3 Pipeline 调整
- 新增开关 `use_agent1_planning`：默认可开，便于回退；关闭时依旧产出占位规划，保持后续步骤不崩。
- `core/gemini_pipeline.py`
  - `_step3_vision_planning` 不再负责装配顺序，可选择保留其“识别基准组件”的能力；如果关闭 Agent1，也要生成占位 `planning_result`：组件列表直接来自 `file_hierarchy`，`assembly_order=drawing_index=index`，`base_part_drawing_number` 默认 1。
  - `_step5_component_assembly`、`_step6_product_assembly` 改为直接遍历 `file_hierarchy['components']` 与 `file_hierarchy['product']`，并把 index 当成装配顺序：
    ```python
    component_plan = {
        "component_code": comp.get("bom_code") or f"COMP_{comp['index']}",
        "component_name": comp.get("name"),
        "assembly_order": comp['index'],
        "drawing_number": comp['index']
    }
    ```
  - 产品部分同理，产品总图列表通常只有 1 个；若仍需基准组件信息，可以让 Agent4 自行识别或保留 Agent1 输出的 `base_component_*` 字段。

### 3.4 焊接/拼装智能体
- `agents/component_assembly_agent.py` + `prompts/agent_3_component_assembly.py`
  - 明确“序号1即基准件”，第一步必须放置序号1，后续按由内到外/由下到上生成步骤，保证 BOM 全覆盖；没有 `base_part_code` 也要能产出完整步骤与 3D 高亮。
- `agents/product_assembly_agent.py` + `prompts/agent_4_product_assembly.py`
  - 明确要求“先寻找基准组件（通常是底座/序号①），第一步放置所有子组件，其余步骤逐一安装零件/紧固件”。
  - 若保留 Agent1 的“基准组件识别”功能，只需把那部分数据传给 Agent4；否则 Agent4 自行处理。

### 3.5 BOM-3D 匹配
- `core/hierarchical_bom_matcher_v2.py`
  - 主键用 `component.index` 直连 PDF/STEP/BOM/GLB，兼容大小写（`组件图{index}.pdf/PDF`）。
  - 不再依赖 `base_part_code`；可用 BOM 序号1的代号做校验但不做硬绑定。
  - `component_level_mappings` 的 key 仍使用 `component_code`；如果文件名没有代号，可使用 `COMP_{index}` 占位。

### 3.6 ManualIntegrator
- `component_assembly` 章节按 `assembly_order`（=文件 index）排序；`metadata.total_components`=组件数量。
- `product_assembly` 章节继续引用拼装智能体输出的 `base_component` 信息；如果 Agent1 关闭则用 Agent4 结果填充，避免为空。
- JSON schema 与前端协议不变，因此 `ManualViewer.vue`、`Generator.vue` 等无需修改。

### 3.7 测试与验收
1. **命名正确**：三份组件图 + 产品图，确认 JSON 输出、3D 高亮、管理员编辑均正常。
2. **命名错误**：缺少对应 STEP/PDF、index 重复、index 断档，确保上传阶段直接报错。
3. **组件基准件**：验证组件图序号1被固定为基准件，Agent3 返回的第一步始终放置序号1。
4. **基准组件识别**：验证拼装智能体始终能识别正确基准组件，并在第一步放置所有子组件。

## 4. 实施步骤清单
1. 在上传层实现文件名/顺序校验。
2. 更新 `core/file_classifier.py`，输出严格的 `assembly_order` 和 PDF/STEP 绑定。
3. 精简或移除 Agent1 的装配顺序逻辑，只保留（可选）基准组件识别。
4. 调整 `core/gemini_pipeline.py`，直接按 `file_hierarchy` 构造输入再调用 Agent3/Agent4。
5. 更新 `prompts/agent_3_component_assembly.py`、`prompts/agent_4_product_assembly.py`，确保智能体能在无 Agent1 提示的情况下自识别基准信息。
6. 调整 `core/hierarchical_bom_matcher_v2.py` 和 `core/manual_integrator_v2.py` 以适配“纯文件顺序”输入。
7. 执行测试计划并记录结果。

## 5. 注意事项
- 该方案完全依赖用户的命名顺序；如果顺序写错，输出也会错。上传 UI、使用指南中必须清楚提示“命名即顺序”。
- 产品基准组件的识别不能删除：即便取消 Agent1，也要在 Agent4 提示词中强调如何判定基准组件，否则总装步骤会混乱。
- 如果未来发现某些项目仍需要 AI 自动规划，只需重新启用 Agent1 的顺序输出即可（现有代码结构支持回滚）。
